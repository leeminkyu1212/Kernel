ë™ê¸°í†µì‹ 
  ë°•ìžì— ë§žì¶°ì„œ í†µì‹ í•œë‹¤.
    â€¢ê°™ì€Clockì„ì‚¬ìš©í•¨

 
ë¹„ë™ê¸°í†µì‹ 
  ì„œë¡œ í†µì‹ ë°•ìžë¥¼ ì•½ì†í•˜ê³  í†µì‹ ì„ ì‹œìž‘í•¨
    â€¢Clock í•„ìš”ì—†ìŒ
    â€¢ì•½ì†ëœì†ë„ë¥¼ ì„œë¡œ ë§žì¶°ì•¼ë§Œ í†µì‹ ì´ ëœë‹¤



RA6E1 MCU ìš”ì•½

Connectivity

  1.Coreì„¤ëª… 
  2.ë©”ëª¨ë¦¬
    ë‹¤ìŒìœ¼ë¡œ ë‚˜ì˜¤ëŠ”ê²Œ í†µì‹ ì¼ ì •ë„ë¡œ í†µì‹ ì´ ì¤‘ìš”í•˜ë‹¤.


ì§€ì›í•˜ëŠ” í†µì‹  ë°©ë²•
  ë‹¤ì–‘í•˜ê²Œ ì§€ì›í•œë‹¤.
    1. â€œSCIâ€ ë¼ëŠ”íŠ¹ì´í•œí†µì‹ Interfaceê°€ìžˆìŒ
    2. I2C ì§€ì›
    3. SPI ì§€ì›
    4. Quad SPI  ì§€ì›(4ë°°ì†SPI)
    5. USBFS (USB í†µì‹ ì§€ì›)
    6. CAN í†µì‹ ì§€ì›
    7. Ethernet í†µì‹ ì§€ì›
    8. SD Cardë¥¼ìœ„í•œí†µì‹ ì§€ì›
    9. Soundë¥¼ìœ„í•œí†µì‹ ì§€ì›


ë¹„í†µê¸° í†µì‹ ì„ í•´ë³¼ ì˜ˆì •
 â€¢ë¥´ë„¤ì‚¬ìŠ¤ MCUëŠ” SCIë¼ê³  ë¶€ë¥´ëŠ” ë‹¨ìˆœ í†µì‹  Interfaceë¥¼ ì§€ì›í•œë‹¤.


Block Diagram
  ìž„ë² ë””ë“œ ë°ì´í„° ì‹œíŠ¸ì—ëŠ” ë¸”ëŸ­ ë‹¤ì´ì–´ê·¸ëž¨ìœ¼ë¡œ ì§€ì›í•˜ëŠ” ê¸°ëŠ¥ì„ ê·¸ë¦¼ìœ¼ë¡œ í‘œí˜„í•˜ê³¤ í•œë‹¤.

ê¸°ì–µí•´ì•¼í•  í†µì‹  ë°©ë²•

SCI : ë¥´ë„¤ì‚¬ìŠ¤ ë³´ë“œì—ì„œ ë¶€ë¥´ëŠ” í†µì‹  Interface
 ìž„ë² ë””ë“œì—ì„œ í”ížˆ ì‚¬ìš©ë˜ëŠ” í†µì‹  ë°©ë²•
 1. IIC (I ê°€2ê°œë¼ì„œI2C ë˜ëŠ”ð¼2ð¶ë¼ê³ ì“´ë‹¤., ë°œìŒì€ì•„ì´ìŠ¤í€˜ì–´ì”¨)
 2. SPI (I2C ë³´ë‹¤ê³ ì†í†µì‹ )
 3. QSPI (Flash Memoryì—ìžì£¼ì“°ëŠ”4ë°°ì†I2C)
 4. Ethernet : ì¼ë°˜ë„¤íŠ¸ì›Œí¬ì—ì„œìžì£¼ì‚¬ìš©
 5. CAN : ìžë™ì°¨ì—ì„œìžì£¼ì‚¬ìš©í†µì‹ ë°©ë²•


LED í•˜ë‚˜ë¥¼ ON/OFF
BASEë¡œ ì•Œì•„ì•¼ ì§€ì‹ë“¤ì´ ë§Žë‹¤.

ì–´ë–¤ ë°©ì‹ì„ ì„ íƒí•´ì„œ ì§„í–‰í•´ì•¼ í•˜ëŠ”ì§€ ê³ ë¯¼í•  ìˆ˜ ìžˆì–´ì•¼ í•¨.
ê³ ë¯¼ì„ í•˜ë ¤ë©´ ì•„ëŠ”ê²Œ ìžˆì–´ì•¼ í•¨.


ì™¸ë¶€ ì¸í„°ëŸ½íŠ¸ ì„¤ì •í•œ í•€ì— ì‹ í˜¸ê°€ ë°”ë€Œì—ˆì„ ë•Œ, callback í•¨ìˆ˜ì— ì •ì˜ëœ ëŒ€ë¡œ ë™ìž‘í•˜ëŠ”ì§€ í…ŒìŠ¤íŠ¸
UART >printf/scanf >> 


//////////////í˜„ê°•

Timer : 
  íŠ¹ì • ì£¼ê¸°ë¡œ ë¹µë¹µë¹µ í˜¸ì¶œë˜ëŠ” ê¸°ëŠ¥
  Threadì²˜ëŸ¼ ë™ìž‘í•´ì•¼ í•œë‹¤
  1. PWM :0,5V ê°€ì•„ë‹ˆë¼ 2.5V 3.3Vë“± ì¤‘ê°„ ë³¼íŠ¸ ë§Œë“¤ë•Œ ì‚¬ìš©í•˜ëŠ”ê²Œ PWM
  ->ì–¸ì œ ì“°ëŠ”ê°€? ì¤‘ê°„ Vì œì–´í•˜ëŠ” ëª¨ë“ˆì— ì‹ í˜¸ ë„£ì„ë•Œ PWM ì‚¬ìš©
  2. ë°ê¸° ì¡°ì ˆ
  3. WDT
  4. í•¸ë“œì‰ì´í¬
    - PING ë³´ë‚´ê³  ì‘ë‹µì™”ë‹ˆ ì§€ì†ì ìœ¼ë¡œ ì²´í¬


```
#include "hal_data.h"
#include "uart_io.h"

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Callback function */
volatile i2c_master_event_t g_i2c_callback_event;
volatile i2c_master_event_t g_iic_callback_event;

void sci_i2c_master_callback(i2c_master_callback_args_t *p_args)
{
    g_i2c_callback_event = p_args->event;
}
/* Callback function */
void iic_callback(i2c_master_callback_args_t *p_args)
{
    g_iic_callback_event = p_args->event;
}

void delay(int ms) {
    R_BSP_SoftwareDelay(ms, BSP_DELAY_UNITS_MILLISECONDS);
}

void hal_entry(void)
{
    setbuf(stdout, NULL);

    uint8_t addr = 0x0;
    uint8_t buf[100] = {0};
    uint8_t str[100]={0};
    while(1) {
        //select addr (by I2C_WRITE)
        addr = 0x0;
        R_SCI_I2C_Write(&g_i2c0_ctrl, &addr, 1, true);
        while(g_i2c_callback_event != I2C_MASTER_EVENT_TX_COMPLETE);

        //read data
        memset(buf, 0, sizeof(buf));
        R_SCI_I2C_Read(&g_i2c0_ctrl, buf, 3, false);
        while(g_i2c_callback_event != I2C_MASTER_EVENT_RX_COMPLETE);

        //print
        sprintf(str,"%X sec %X min %X hours\r\n",buf[0],buf[1],(buf[2]&0xF));
        printf("%s\r\n", str);
        delay(500);
////tempurture
        addr = 0x11;
        R_SCI_I2C_Write(&g_i2c0_ctrl, &addr, 1, true);
        while(g_i2c_callback_event != I2C_MASTER_EVENT_TX_COMPLETE);

        //read data
        memset(buf, 0, sizeof(buf));
        R_SCI_I2C_Read(&g_i2c0_ctrl, buf, 2, false);
        while(g_i2c_callback_event != I2C_MASTER_EVENT_RX_COMPLETE);

        //print
        sprintf(str,"Temp: %d.%d\r\n",buf[0],(buf[1]>>6),(buf[1]>>6)*25);
        printf("%s\r\n", str);
    }
}

void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {

    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
        R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);
        R_IIC_MASTER_Open(&g_i2c_master0_ctrl, &g_i2c_master0_cfg);
        R_SCI_I2C_Open(&g_i2c0_ctrl, &g_i2c0_cfg);
    }
}

```
