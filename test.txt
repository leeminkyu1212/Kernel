1.system call
유닉스 시스템에서의 인터페이스
운영체제의 커널이 제공하는 서비스에 대해, 응용프로그램의 요청에 따라 커널에 접근
하기 위한 인터페이스
고급 api를 통해 시스템 호출에 접근하는 방법

2.디바이스 드라이버
 - /dev/ 디렉터리에서 확인 가능
 - ls -al 시, 맨 앞에 c: 캐릭터
		b: 블록
		d: 디렉토리

3. ls -al 시 , major number와 minor number 확인가능
4. 디바이스 파일은 디바이스 노드라고도 한다.
->디바이스 파일이 디바이스 드라이버는 아니다.
5. app은 하드웨어 직접 접근 불가능, app은 디바이스 파일을 통해 하드웨어를 제어
 시스템콜 :ioctl ,open close readwrite
하드웨어 변경시 커널 빌드를 할 필요없이 디바이스 드라이버만 다시 제작하면 된다.
6. sw 인터페이스를 통해 ,애플리케이션이 하드웨어 스펙을 이해하지 않아도 된다.
7.펌웨어나 디바이스 드라이버나 속도 비교 개발 난이도 무의미하다. 연봉 비교도 무의미하다.
8.애플리케이션과 커널은 분리되어있기 때문에 ,앱 코드에 디바이스 드라이스에서 쓰는 
라이브러리 코드 등 쓸수 없다. 
9. 함수는 static, 전역변수 자주 사용 안함
함수명을 모듈명_xxxx로 짓는 경향이 있다.
10. ioctl: 하드웨어 제어를 목적으로 사용하는 input output control이라는 의미의 시스템 콜
11. 커널 모듈:
	커널 내부에 삽입(insmod) /제거(rmmod) 될 수 있는 바이너리
	디바이스 드라이버는 커널 빌드시 모듈 형태로 포함될 수 있으나,
	디바이스 드라이버는 모두 다 커널 모듈은 아님
	디바이스 드라이버는 커널 모듈 형태로 장치를 제어할 수 있다.

12. chrdev vs blkdev vs netdev
-바이트 단위로 값 전달: chrdev
-블록 단위로 값 전달: blkdev
-네트워크 소켓 :netdev

13.커널 빌드
	-특정 커널 버전에 맞는 디바이스 드라이버 개발
	-커널 헤더를 얻기 위함
	-커널 헤더는 디바이스 드라이버 개발 시 반드시 필요
	-커널 헤더만 따로 설치 가능(라즈베리파이도 리눅스이다.)
	-커널 빌드하면 커널 헤드는 부산물
	-커널 빌드를 한다고 해서 보드 작동 테스트를 할수 있는것은 아니다.

14.mknod
	노드 파일 만드는 명령어 =>유틸리티

 insmod 커널에 디바이스 드라이버 모듈을 넣을때 
 rmmod 커널에 디바이스 드라이버 모듈을 밸때 

file operations 구조체: application에서 디바이스 파일에 시스템 콜 사용시 호출 될 함수

open() - .open
close() - .release

insmod - module_init()
rmmod - module_exit()

15.
dmesg -w
커널로그 실시간 확인

uname -r
커널 버전 확인
16.
major vs minor num

major num
-제어하려는 디바이스를 구분하기 위해 커널이 사용하는 번호의 이름
-디바이스 파일에서 디바이스를 구분하고자 사용하는 번호
-즉, 디바이스 종류

minor num
-개발자가 정하기 나름. 하위 카테고리
17.
BIOS
- 기본적인 i/o를 위한 펌웨어
-부팅 시 바로 동작
-cmos 값도 수정이 가능
UEFI
-BIOS를 대체하는 펌웨어
-gui
-GPT:2.2tb 이상의 디스크 사용 지원

POST
-컴퓨터에 전원 공급시, 패리퍼럴 동작 확인을 위해 BIOS가 동작시키는 진단 과정
18.
Cross vs nativ compile

cross compile
-타겟보드와 개발보드의 코어 종류가 다른 환경에서,
-타겟 보드에 맞는 컴파일러로 컴파일
-개발의 편의 증가
- 빌드 속도도 빠름
-빌드된 결과물은 상대적을 느릴수 밖에

native compile
-해당 타겟보드에서 컴파일
- 개발 불편함
-빌드 속도도 느림
-빌드된 결과물은 빠름
19.
부트로더
 -운영체제가 시동되기 이전에 미리 실행되면서
 -커널이 올바르게 동작하기 위해 필요한 모든 관련작업을 마무리하고
 -os를 시동시키기 위한 목적을 가진 프로그램
 -'부트스트랩' 또는 "부트스트랩 로더" 라고도 부름
 -GRUB, U-BOOT 많이 쓰임

BL0: 메모리 /필수 장치를 초기화하고, BL1 또는 BL2 부트로더 적재 후, 제어권 넘김
 칩셋 회사에서 만듬
 커널을 적재하지 않는다.
GRUB
-grand unified bootloader
-리눅스 배포판에서 많이 사용되는 부트로더

U-Boot 
-arm 계열에서 자주 쓰이는 오픈소스 부트로더
-BL1 또는 BL2 부트로더, 리눅스 커널 적재 시 사용
-Universal Bootloader. 임베디드에서 인기있는데,
-여러 디바이스 들이 쓸수 있는 통합형 부트로더
-메모리 ,디스크에 적힌 값 확인 가능
- 커멘드 모드에서 사용자 정의코드를 만들어, 디바이스 드라이버 없이 gpio 제어 코드를 만들 수 있음
- u-boot 메모리 및 파일 시스템을 거치지 않은 장치 테스트 프로그램을 제작할수 있다.
- 파일 시스템 내부 파일 확인 가능(ls)
- 즉, 부트로더지만 mmc 장치의 파일시스템도 확인 가능
- 부트로더이기 때문에 os에서 쓰는 프로그램 못쓴다

20.
리눅스에서 디바이스 드라이브 개발 vs 부트로더에서 펌웨어 개발

메모리
커널에 모듈 형태로 디바이스 드라이버를 제작하여 넣는 방식으로 개발
uboot에서 하는 이유는 그렇게 하기 싫어서 이다.


